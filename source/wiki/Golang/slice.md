

https://github.com/darjun/you-dont-know-go

## 你不知道的 slice

1. 空切片等于`nil`吗？

下面代码的输出什么？

| `1 2 3 4 5 6 7 8 9 ` | `func main() {  var s1 []uint32  s2 := make([]uint32, 0)   fmt.Println(s1 == nil)  fmt.Println(s2 == nil)  fmt.Println("nil slice:", len(s1), cap(s1))  fmt.Println("cap slice:", len(s2), cap(s2)) } ` |
| -------------------- | ------------------------------------------------------------ |
|                      |                                                              |

分析：

首先`s1`和`s2`的长度和容量都为 0，这很好理解。比较切片与`nil`是否相等，实际上要检查`slice`结构中的`array`字段是否是空指针。显然`s1 == nil`返回`true`，`s2 == nil`返回`false`。尽管`s2`长度为 0，但是`make()`为它分配了空间。**所以，一般定义长度为 0 的切片使用`var`的形式**。

1. 传值还是传引用？

下面代码的输出什么？

| `1 2 3 4 5 6 7 ` | `func main() {  s1 := []uint32{1, 2, 3}  s2 := append(s1, 4)   fmt.Println(s1)  fmt.Println(s2) } ` |
| ---------------- | ------------------------------------------------------------ |
|                  |                                                              |

分析：

为什么`append()`函数要有返回值？因为我们将切片传递给`append()`时，其实传入的是`runtime.slice`结构。这个结构是按值传递的，所以函数内部对`array/len/cap`这几个字段的修改都不影响外面的切片结构。上面代码中，执行`append()`之后`s1`的`len`和`cap`保持不变，故输出为：

| `1 2 ` | `[1 2 3] [1 2 3 4] ` |
| ------ | -------------------- |
|        |                      |

所以我们调用`append()`要写成`s = append(s, elem)`这种形式，将返回值赋值给原切片，从而覆写`array/len/cap`这几个字段的值。

初学者还可能会犯忽略`append()`返回值的错误：

| `1 ` | `append(s, elem) ` |
| ---- | ------------------ |
|      |                    |

这就更加大错特错了。添加的元素将会丢失，以为函数外切片的内部字段都没有变化。

我们可以看到，虽说切片是按引用传递的，但是实际上传递的是结构`runtime.slice`的值。只是对现有元素的修改会反应到函数外，因为底层数组空间是共用的。

1. 切片的扩容策略

下面代码的输出是什么？

| `1 2 3 4 5 6 ` | `func main() {  var s1 []uint32  s1 = append(s1, 1, 2, 3)  s2 := append(s1, 4)  fmt.Println(&s1[0] == &s2[0]) } ` |
| -------------- | ------------------------------------------------------------ |
|                |                                                              |

这涉及到切片的扩容策略。扩容时，若：

- 当前容量小于 1024，则将容量扩大为原来的 2 倍；
- 当前容量大于等于 1024，则将容量逐次增加原来的 0.25 倍，直到满足所需容量。

我翻看了 Go1.16 版本`runtime/slice.go`中扩容相关的源码，在执行上面规则后还会根据切片元素的大小和计算机位数进行相应的调整。整个过程比较复杂，感兴趣可以自行去研究。

我们只需要知道一开始容量较小，扩大为 2 倍，降低后续因添加元素导致扩容的频次。容量扩张到一定程度时，再按照 2 倍来扩容会造成比较大的浪费。

上面例子中执行`s1 = append(s1, 1, 2, 3)`后，容量会扩大为 4。再执行`s2 := append(s1, 4)`由于有足够的空间，`s2`底层的数组不会改变。所以`s1`和`s2`第一个元素的地址相同。

1. 切片操作符可以切取字符串

切片操作符可以切取字符串，但是与切取切片和数组不同。切取字符串返回的是字符串，而非切片。因为字符串是不可变的，如果返回切片。而切片和字符串共享底层数据，就可以通过切片修改字符串了。

| `1 2 3 4 ` | `func main() {  str := "hello, world"  fmt.Println(str[:5]) } ` |
| ---------- | ------------------------------------------------------------ |
|            |                                                              |

输出 hello。

1. 切片底层数据共享

下面代码的输出是什么？

| ` 1 2 3 4 5 6 7 8 9 10 11 ` | `func main() {  array := [10]uint32{1, 2, 3, 4, 5}  s1 := array[:5]   s2 := s1[5:10]  fmt.Println(s2)   s1 = append(s1, 6)  fmt.Println(s1)  fmt.Println(s2) } ` |
| --------------------------- | ------------------------------------------------------------ |
|                             |                                                              |

分析：

首先注意到`s2 := s1[5:10]`上界 10 已经大于切片`s1`的长度了。要记住，**使用切片操作符切取切片时，上界是切片的容量，而非长度**。这时两个切片的底层结构有重叠，如下图：

![img](https://cdn.jsdelivr.net/gh/gbxhq/Pic/202205311808392.png)

这时输出`s2`为：

| `1 ` | `[0, 0, 0, 0, 0] ` |
| ---- | ------------------ |
|      |                    |

然后向切片`s1`中添加元素 6，这时结构如下图，其中切片`s1`和`s2`共享元素 6：

![img](https://darjun.github.io/img/in-post/youdontknowgo/slice4.png#center)

这时输出的`s1`和`s2`为：

| `1 2 ` | `[1, 2, 3, 4, 5, 6] [6, 0, 0, 0, 0] ` |
| ------ | ------------------------------------- |
|        |                                       |

可以看到由于切片底层数据共享可能造成修改一个切片会导致其他切片也跟着修改。这有时会造成难以调试的 BUG。为了一定程度上缓解这个问题，Go 1.2 版本中提供了一个扩展切片操作符：`[low:high:max]`，用来限制新切片的容量。使用这种方式产生的切片容量为`max-low`。

| ` 1 2 3 4 5 6 7 8 9 10 11 ` | `func main() {  array := [10]uint32{1, 2, 3, 4, 5}  s1 := array[:5:5]   s2 := array[5:10:10]  fmt.Println(s2)   s1 = append(s1, 6)  fmt.Println(s1)  fmt.Println(s2) } ` |
| --------------------------- | ------------------------------------------------------------ |
|                             |                                                              |

执行`s1 := array[:5:5]`我们限定了`s1`的容量为 5，这时结构如下图所示：

![img](https://cdn.jsdelivr.net/gh/gbxhq/Pic/202205311808079.png)

执行`s1 = append(s1, 6)`时，发现没有空闲容量了（因为`len == cap == 5`），重新创建一个底层数组再执行添加。这时结构如下图，`s1`和`s2`互不干扰：

![img](https://cdn.jsdelivr.net/gh/gbxhq/Pic/202205311808431.png)